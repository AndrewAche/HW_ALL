# Домашнее задание к занятию 06-db-06 «Troobleshooting» - `Ачеусов Андрей`

### Задание 1

В первую очередь необходимо вычеслить проблемные запросы, посредством команды:  
`db.currentOp({“secs_running”:{$gte:5}})`  
  
Затем можно остановить полученную операцию через:  
`db.killOp();`
  
Решить проблему с долгими запросами можно перестроив существующие индексы или ограничив максимальное время на выполнение запроса или увеличив память)

---


### Задание 2


Причина в том, что панять более чем на 75% забита старыми ключами, которые пока не были вычещены:  
![image](https://github.com/AndrewAche/HW_ALL/assets/121398221/65f1764d-b46e-4e53-a468-ec2c6dd76925)


---


### Задание 3

Представленная ошибка cвязана с увеличением кол-ва записей в БД, что спровоцировало рост времени на SELECT информации внутри такой таблицы. Время запроса превысило таймаут.
Возможно несколько решений представленной проблемы:  

* Самое очевидное - это увеличений мощности машины,
* Второе, также очевидное - увеличения времени таймаута запроса в конфигурации,
* А также создание индексов и вертикальное шардирование (парцирование) таблиц для оптимизации запросов к БД,
* Горизонтальное шардирование (масштабирование) таблиц, что по сути ознает рост мощностей посредством создания/расширения кластера.

---


### Задание 4

Out-Of-Memory Killer — это процесс, который завершает приложение, чтобы спасти ядро от сбоя. Он жертвует приложением, чтобы сохранить работу ОС.   

Если причина увеличения памяти связана напрямую с PostgreSQL тогда можно смаштабировать память используя такие значения как:

`shared_buffers`  
Объём совместно используемой памяти, выделяемой PostgreSQL для кэширования данных, определяется числом страниц (shared_buffers) по 8 килобайт каждая. Следует учитывать, что операционная система сама кеширует данные, поэтому нет необходимости отводить под кэш всю наличную оперативную память.  

`temp_buffers`  
Задаёт максимальный объём памяти, выделяемой для временных буферов в каждом сеансе.  
 
`work_mem`  
Задаёт базовый максимальный объём памяти, который будет использоваться во внутренних операциях при обработке запросов (например, для сортировки или хеш-таблиц), прежде чем будут задействованы временные файлы на диске.  
 
Что касается непосредственного самой ОС если проблема не связана с банальной нехваткой ресурсов тогда:  

Можно использовать `vm.overcommit_memory` он может иметь одно из трёх значений:  

```
0: ядро может выделить больше виртуальной памяти, чем доступно реально, но при этом полагается на “эвристический алгоритм” (heuristic overcommit handling) при принятии решения о выделении или об отказе  
1: ядро всегда будет выполнять overcommit, что увеличивает вероятность ошибок Out of memory, но должно позитивно влиять на производительность процессов, активно использующих память  
2: ядро не будет выделять памяти больше, чем определено в overcommit_ratio или overcommit_kbytes  
vm.overcommit_ratio — процент оперативной памяти, доступной для чрезмерной загрузки.  
```

Та же можно настроить swap: указать в параметре vm.swappiness значение побольше (по-умолчанию = 60), чтобы ядро начало использовать swap раньше.  

---


